# 1.SQL优化

1. 在表中建立索引，优先考虑where、group by使用到的字段。
2. 尽量避免使用select *，返回无用的字段会降低查询效率。
3. 尽量避免使用in 和not in，会导致数据库引擎放弃索引进行全表扫描。
4. 尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。
5. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。
6. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。

# 2. 索引

## 1.索引有哪些

> 普通 主键 唯一 组合

## 2.什么时候加索引

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中与其他表关联的字段，外键关系建立索引
4. 单键/组合索引的选择问题，组合索引的性价比更高
5. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
6. 查询中统计或者分组字段。
7. 过滤条件好的字段选择一段选择加索引

## 3. 组合索引

有序

# 3.事务

## 1.事务的隔离级别

读未提交（Read Uncommitted）
读提交（Read Committed）   使用“快照读（Snapshot Read）”，避免“脏读”
可重复读（Repeated Read）  快照读（Snapshot Read）”，锁住被读取记录，避免出现“脏读”、“不可重复读”
串行化（Serializable）            有效避免“脏读”、“不可重复读”、“幻读”
为什么会出现“脏读”？因为没有“select”操作没有规矩。
为什么会出现“不可重复读”？因为“update”操作没有规矩。
为什么会出现“幻读”？因为“insert”和“delete”操作没有规矩。

## 2.Spring事务管理

1. 编程式事务管理对基于 POJO 的应用来说是唯一选择。我们需要在代码中调用beginTransaction()、commit()、rollback()等事务管理相关的方法，这就是编程式事务管理。
2. 基于 TransactionProxyFactoryBean的声明式事务管理
3. 基于 @Transactional 的声明式事务管理
4. 基于Aspectj AOP配置事务

# 4. JVM

1. 强引用
2. 软引用
3. 弱引用
4. 虚引用

